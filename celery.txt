celery:a distributed task queue that would let you offload anywork from your application

TO MAKE USE OF CELERY YOU NEED:
-Django Application and a celery server running e.g windows,linux or mac
-Task Broker to mitigate all of our task RabbitMQ or Redis

TASK OF CELERY:
-generating complex reports,processing lots of dataset,potentially performing computationally intensive operations,
-running machine learning models,
-sending confirmation emails,
-webscraping and crawling
-processing images
-generating reports
-data analysis/processing

CELERY TASKS:
-Asynchronous Task Execution
-Distributed Task Queue
-Task Scheduling and Periodic Tasks
-Results Handling
-Error Handling and Retry Mechanism
-Monitoring and Management

django(message provider)-redis(message brocker)-celery(celery worker)-DB(Result Backend)

celery- worker that handles time consuming tasks effortlessly offloading the work from the app itself

celery workers-they excute the task that was produce by the task producers,they form the backbone of the celery architecture,they also listen to the message broker for incoming tasks and performs the assigned operations,this then potentionally produced a result that is sent back to the message provider for further processing,they can also be distributed across multiple machines or run on seperate processes on the same machine,to handle task concurrently and be scalable,workers are design to be highly available and full tolerant ensuring that task are processed reliably and efficiently,they communicate with the message broker report task status,and handle task priotization,and support various advance features e.g task routing,error handling,retry mechanism

redis-hidden memory data-structure store,that can be use as a database message cache broker store because of how it works compare to traditional datbase,it is know for allowing quick read and write operations and it supports whole range of data structures

ENTRYPOINT/CMD:
    Entrypoint.sh- entrypoint.sh is a shell script (or any executable script) that Docker runs automatically when the container starts.

    Think of it as the first command your container executes ‚Äî the ‚Äúentry point‚Äù into your app.

    In Docker, there are two ways to specify what the container runs:
        -ENTRYPOINT ‚Üí defines the base command
        -CMD ‚Üí defines default arguments to pass to the entrypoint
    Example:
        ENTRYPOINT ["/app/entrypoint.sh"]
        CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
    commands
        -#!/bin/sh:(Debian‚Äôs default shell)
            WHY IT WORKS:
                -python:3.12-slim has /bin/sh (Debian‚Äôs default shell)
                -It‚Äôs POSIX compliant, enough for most scripts (like your entrypoint.sh)
                Compatible across different images
        -echo ‚Üí just prints a message
        -python manage.py migrate ‚Üí applies database migrations automatically every container start
        -exec "$@" ‚Üí runs whatever command you passed in docker-compose.yml (in your case, python manage.py runserver 0.0.0.0:8000)

    POSIX: stands for Portable Operating System Interface.
        It is a standard that defines:
            -How operating systems should behave
            -How shell commands, utilities, and scripts should work

        The goal: 
            write scripts that run on any compliant Unix-like system (Linux, macOS, etc.) without modification.

    A POSIX shell script is:
        -A script written in a standard shell syntax defined by POSIX
        -Uses only commands and syntax that are guaranteed to exist on any POSIX-compliant system
        -Usually run with #!/bin/sh

        e.g:
            ‚úÖ Example of a POSIX-compliant shell script
                #!/bin/sh
                echo "Hello, World!"
                for file in *.txt; do
                    echo "Found $file"
                done


                -Works on Debian, Ubuntu, Alpine, macOS, FreeBSD, etc.

                -Uses standard POSIX syntax: for, do/done, echo


    SHEBANG(#!/bin/sh, #!/bin/bash, #!/bin/ash): 
        It tells the operating system which interpreter to use to run the script.

        Without it, the OS may try to run the script with the default shell (which might not exist), causing errors.
        THE DIFFERENT OPTIONS:
            - Debian/Ubuntu slim(#!/bin/sh): uses POSIX-compliant shell interpreter,it's Very standard, and almost always exists in Docker base images. Minimal shell functionality.
            -Bash features needed(#!/bin/bash): uses bash shell interpreter,More features (arrays, [[ ]], source, etc.), but not guaranteed in slim Docker images. Often not installed by default(must be installed in image).
            -Alpinelinus(#!/bin/ash): uses Armquist shell interpreter,Used in Alpine Linux images (very tiny images). Not available in Debian/Ubuntu based images.

üîπ POSIX vs Bash Cheat Sheet

This will help you know what commands/syntax are safe in /bin/sh (POSIX) and what is Bash-only.

+--------------------------+----------------+-----------+----------------------------------------------+
| Feature / Command        | POSIX (/bin/sh)| Bash-only | Notes                                        |
+--------------------------+----------------+-----------+----------------------------------------------+
| Shebang                  | #!/bin/sh      | #!/bin/bash| Use /bin/sh for portability                  |
| Echo                     | ‚úÖ             | ‚úÖ         | Both work                                    |
| For loop                 | ‚úÖ             | ‚úÖ         | for var in ...; do ...; done works in POSIX |
| Arrays                   | ‚ùå             | ‚úÖ         | Only Bash supports arrays (arr=(1 2 3))    |
| [[ ... ]] conditional    | ‚ùå             | ‚úÖ         | Use [ ... ] in POSIX scripts               |
| String slicing           | ‚ùå             | ‚úÖ         | Bash: ${var:0:3}                            |
| Source / . command       | ‚úÖ             | ‚úÖ         | Both POSIX and Bash support . filename      |
| Functions                | ‚úÖ             | ‚úÖ         | myfunc() { ... } works                        |
| Arithmetic               | ‚úÖ             | ‚úÖ         | POSIX: expr $a + $b or $((a+b))            |
| read                     | ‚úÖ             | ‚úÖ         | Works the same                               |
| ${var//old/new} replacement| ‚ùå           | ‚úÖ         | Bash-only string replacement                 |
+--------------------------+----------------+-----------+----------------------------------------------+

Task Priotization-involves the managing execution order,and result allocation of task,to define the relative importance and urgency of tasks,so that critical task are handled promptly and resources are utilized efficiently

Task Priority: This is the act of carrying out high priority tasks before lower priority tasks(0-9) Allowing you to manage the order in which tasks are executed, in other words it empowers us to manage the execution order of task,helps us to optimize results allocation,helps us to meet deadlines and effectively handle deadlines critical or time sensitive requests in our application.
Why Prioritize task?
    1.)Ensure Critical task are executed first
    2.)optimized resource utilization
    3.)meet SLA's and deadlines
    4.)Handle High Priority or time-sensitive requests efficiently
